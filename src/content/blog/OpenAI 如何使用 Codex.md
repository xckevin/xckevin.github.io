---
title: OpenAI 如何使用 Codex
excerpt: OpenAI 团队总结了 Codex 在真实工程场景中的 7 类高频用法，并分享了可复用的提示词与流程最佳实践。本文帮助工程师在代码理解、重构、性能与测试等任务中更高效地落地 Codex。
publishDate: 2026-03-01
tags:
  - Codex
  - AI
  - 软件工程
  - 开发效率
seo:
  title: OpenAI 如何使用 Codex
  description: OpenAI 团队基于内部访谈与使用数据，整理 Codex 的 7 类工程用例与最佳实践，覆盖代码理解、重构、性能优化、测试与效率提升。
---



> **总结**：这篇文章基于 OpenAI 内部团队的真实使用场景，梳理 Codex 如何帮助工程师在复杂代码库中更快上手、排障与交付。它强调 Codex 在“理解—改动—验证—迭代”全链路中的价值，以及在高压任务与碎片化工作下保持效率的方法。文中提供了 7 类高频用例、可直接复用的提示词，以及一套从 Ask Mode 到 Code Mode 的实用流程。读者可以据此将 Codex 作为日常开发的“加速器”，系统化提升产出与质量。

![封面视觉 5](../../assets/openai-ru-he-shi-yong-codex-5.png)

## 引言

Codex 在 OpenAI 的多个技术团队中被高频使用，例如安全、产品工程、前端、API、基础设施与性能工程等。团队用它加速各类工程任务：从理解复杂系统、重构大型代码库，到在紧迫期限下上线新功能与处置故障。

本文基于对 OpenAI 工程师的访谈与内部使用数据，整理出一系列用例与最佳实践，展示 Codex 如何帮助团队更快推进、提升工作质量，并在规模化工程中有效管理复杂度。

## 使用场景

### 用例 1：代码理解

Codex 能帮助工程师在不熟悉的代码区快速建立理解，无论是新同学上手、排查 bug，还是处置线上事故。

团队经常用 Codex 定位功能的核心逻辑、梳理服务或模块间的关系、追踪系统中的数据流。它还会暴露一些架构模式或缺失的文档线索，这些通常需要大量人工梳理。

在事故响应场景中，Codex 还能快速帮助工程师理解组件间的交互，或追踪故障状态如何在系统中传播。

**来自团队的故事**：
- “修 bug 时，我会用 Ask Mode 找出代码里其它可能出现相同问题的位置。”—— 性能工程师（检索系统）
- “值班时我把堆栈贴进去问：‘在哪儿实现的？’，Codex 会直接跳到 auth 仓库里相关流程所在的位置。”—— 站点可靠性工程师（API 平台）
- “它能跨 Terraform 和 Python 把我带到正确文件，比 grep 快三太多。”—— DevOps 工程师（基础设施服务）

**可用提示词示例**：
- 这个仓库里认证逻辑实现在哪？
- 总结该服务从入口到响应的请求流转路径。
- 哪些模块会与 [模块名] 交互？失败时如何处理？

### 用例 2：重构与迁移

Codex 常用于跨多文件或多包的修改。例如更新 API、调整实现模式或迁移依赖时，它能帮助工程师一致性地应用变更。

当同样的更新需要覆盖几十个文件，或变更涉及复杂结构与依赖，难以用正则或简单替换完成时，Codex 的优势尤为明显。

团队也用它做代码清理：拆分过大的模块、用现代模式替换旧方案，或为更可测的结构做准备。

**来自团队的故事**：
- “Codex 把所有 legacy 的 getUserById() 替换成新服务模式，并直接开了 PR。几分钟完成了原本要花数小时的工作。”—— 后端工程师（ChatGPT Web）
- “为了解决上线阻塞，我让 Codex 扫描旧模式的所有实例，用 Markdown 总结影响，然后开 PR 修复。”—— 产品工程师（ChatGPT Enterprise）

**可用提示词示例**：
- 按职责把这个文件拆成多个模块，并为每个模块生成测试。
- 把所有基于回调的数据库访问改成 async/await。

### 用例 3：性能优化

Codex 用于发现并解决性能瓶颈。

在性能调优或稳定性提升过程中，工程师会让 Codex 分析慢路径或高内存消耗的代码，例如低效循环、冗余操作或昂贵查询，并给出优化方案，常能带来可观的效率与可靠性提升。

它还被用于代码健康治理，识别仍在使用的风险或过时模式，帮助减少长期技术债并主动防止回归。

**来自团队的故事**：
- “我会用 Codex 扫描重复的昂贵 DB 调用。它很擅长标出热点，并帮我起草可批量化的查询。”—— 基础设施工程师（API 可靠性）
- “它在发现性能问题上非常快。我花 5 分钟写提示词，就节省了 30 分钟排查。”—— 平台工程师（模型服务）

**可用提示词示例**：
- 优化这个循环的内存效率，并解释为什么更快。
- 找出这个请求处理器里重复的昂贵操作，并建议缓存点。
- 给出更快的方式来批量执行这段函数里的 DB 查询。

### 用例 4：提升测试覆盖

Codex 能帮助工程师更快写测试，尤其在覆盖率薄弱或缺失的区域。

当修 bug 或重构时，工程师会让 Codex 建议覆盖边界情况或潜在失败路径的测试。对于新代码，它也能根据函数签名与周边逻辑生成单元或集成测试。

它特别擅长发现边界条件，比如空输入、最大长度、或少见但合法的状态，这些往往在初次测试时被忽略。

**来自团队的故事**：
- “我会把低覆盖率模块交给 Codex 跑一晚上，醒来就有可运行的单元测试 PR。”—— 前端工程师（ChatGPT Desktop）
- “切换 monorepo 分支太麻烦时，我让 Codex 写测试并启动 CI，我继续在自己的分支上干活。”—— 后端工程师（支付与计费）

**可用提示词示例**：
- 为这个函数写单元测试，包含边界与失败路径。
- 为这个排序工具生成 property-based 测试。
- 扩展该测试文件，覆盖 null 输入与无效状态等缺口。

### 用例 5：提升开发速度

Codex 通过加速开发周期的“开始”和“收尾”阶段帮助团队更快交付。

新功能启动时，工程师用它搭脚手架：生成目录、模块与 API stub，快速得到可运行的起步代码。

接近上线时，Codex 能处理一些小但关键的工作，比如排查 bug、补齐最后的实现缺口、生成发布脚本、遥测 hooks 或配置文件，帮助赶进度。

它也能把产品反馈转成起步代码。工程师常把用户需求或规格说明直接贴进来，让 Codex 生成初稿，后续再迭代完善。

**来自团队的故事**：
- “我整天在开会，但仍然合并了 4 个 PR，因为 Codex 在后台替我工作。”—— 产品工程师（ChatGPT Enterprise）
- “Codex 帮我完成了 3-4 个低优先级修复，不然会一直躺在 backlog 里。”—— 全栈工程师（内部工具）

**可用提示词示例**：
- 为 POST /events 搭一个新 API 路由，包含基础校验与日志。
- 用这个模板 [插入你的遥测代码示例] 生成一个 onboarding 成功/失败的遥测 hook。
- 根据这份规格说明生成一个 stub 实现：[插入 spec 或产品反馈]。

### 用例 6：保持专注与连续性

Codex 帮助工程师在时间被打断时依然保持高产。

它可以捕捉未完成的工作、把笔记转成可运行原型，或拆出可稍后回来的探索性任务。这样在值班或会议繁多时，暂停和恢复工作就不会丢失上下文。

**来自团队的故事**：
- “遇到临时修复，我会直接发 Codex 任务，不切分支，等有空再 review 它的 PR。”—— 后端工程师（ChatGPT API）
- “我经常把 Slack 线程、Datadog 追踪和 issues 转给 Codex，这样我可以专注在高优先级工作上。”—— API 工程师（可观测性）

**可用提示词示例**：
- 生成一个重构该服务的计划，并拆分成更小模块。
- 先写出重试逻辑的骨架并加 TODO——我会稍后补回退策略。
- 总结这个文件，方便我明天接着做。

### 用例 7：探索与方案发散

Codex 同样适合开放式任务，如探索替代方案或验证设计决策。你可以让它给出多种解法、探索不熟悉的模式，或对假设进行压力测试，从而看清权衡、扩展设计空间并优化实现。

它还可用于发现相关 bug。给定一个已知问题或过时方法，Codex 能定位其它相似模式，便于减少回归或完成清理。

**来自团队的故事**：
- “它帮我解决冷启动问题——我贴上 spec 和文档，它会搭出代码或提醒我漏了什么。”—— 产品工程师（ChatGPT Desktop）
- “修完一个 bug 后，我会问 Codex 类似问题可能还藏在哪，再继续开跟进任务。”—— 性能工程师（检索系统）

**可用提示词示例**：
- 如果把系统从 request/response 改成 event-driven，会怎么实现？
- 找出所有手动拼 SQL 而非使用 query builder 的模块。
- 把这段改成更函数式的风格，避免 mutation 与 side effects。

## 最佳实践

Codex 在具备结构化上下文与迭代空间时表现最佳。以下是 OpenAI 团队在日常使用中培养的习惯：

### 从 Ask Mode 开始

对较大的改动，先用 Ask Mode 让 Codex 输出实现计划，再切换到 Code Mode 做后续修改。这个两步流程能让 Codex 保持“对齐”，减少输出错误。

Codex 最适合处理范围明确的任务：大约相当于你或同事 1 小时的工作量，或几百行代码的实现。随着模型能力提升，它能承担的任务规模也会扩大。

### 迭代完善 Codex 的开发环境

配置启动脚本、环境变量以及互联网访问权限，可以显著降低 Codex 的出错率。执行任务时，留意构建错误并在 Codex 环境配置中修复。这个过程可能需要多次迭代，但长期看能带来明显效率提升。

### 像写 GitHub Issue 一样组织提示词

当提示词结构与 PR/Issue 描述一致时，Codex 的表现更好。建议包含文件路径、组件名、diff 片段或文档摘录等信息。

类似“按 [模块 X] 的方式实现”这样的提示模式能显著提升结果质量。

### 用 Codex 任务队列当轻量 backlog

把发散想法、半成品任务或顺手修复事项都丢给 Codex。无需一次生成完整 PR，它可以作为一个随时可回来的临时工作区。

### 用 AGENTS.md 提供长期上下文

维护 AGENTS.md 文件，帮助 Codex 在仓库里跨多次提示词高效工作。这类文件通常包含命名规范、业务逻辑、已知怪癖或代码本身无法推断的依赖。

### 用 Best of N 提升输出质量

Best of N 功能可一次生成多个方案，方便快速比较并择优。面对复杂任务时，你可以融合不同回答的优点，得到更强的最终方案。

## 展望

Codex 仍处于研究预览阶段，但已经在我们的开发方式上产生真实影响：帮助团队更快推进、写出更优质的代码，并承担那些原本可能被搁置的工作。

我们对未来充满期待。随着模型持续进步、Codex 更深入地融入工作流，我们相信会解锁更多强大的软件开发方式，并将继续分享实践经验。

---

> 本文翻译自：[How OpenAI uses Codex](https://cdn.openai.com/pdf/6a2631dc-783e-479b-b1a4-af0cfbd38630/how-openai-uses-codex.pdf)
