---
title: 高级数据持久化与缓存策略
excerpt: 数据是现代应用程序的命脉。无论是用户生成的内容、从网络获取的信息，还是应用的配置状态，如何高效、可靠地在设备本地进行持久化存储（Persistence）、检索（Retrieval）、缓存（Caching），都直接决定了应用的性能表现、离线可用性以及对网络和电池资源的消耗。
publishDate: 2025-02-24
tags:
  - Android
  - 数据存储
  - Room
  - 缓存
seo:
  title: 高级数据持久化与缓存策略
  description: 数据是现代应用程序的命脉。无论是用户生成的内容、从网络获取的信息，还是应用的配置状态，如何高效、可靠地在设备本地进行持久化存储（Persistence）、检索（Retrieval）、缓存（Caching），都直接决定了应用的性能表现、离线可用性以及对网络和电池资源的消耗。
---
# 高级数据持久化与缓存策略

## 引言：数据的生命力与智慧管理

数据是现代应用程序的命脉。无论是用户生成的内容、从网络获取的信息，还是应用的配置状态，如何高效、可靠地在设备本地进行**持久化存储（Persistence）**、**检索（Retrieval）**、**缓存（Caching）**，都直接决定了应用的性能表现、离线可用性以及对网络和电池资源的消耗。

对于 Android 开发者而言，仅仅掌握 SharedPreferences 的基本读写或 Room 的简单增删改查是远远不够的。**必须精通数据库（特别是 SQLite/Room）的深度优化技巧（索引、查询计划、事务、WAL）、理解现代键值存储方案（DataStore、MMKV）的内部机制与权衡、能够设计和实现复杂的多级缓存架构、掌握缓存一致性与失效策略、构建健壮的离线优先（Offline-First）模式，并能高效处理大型数据和文件。** 数据持久化与缓存策略的选择和实施，是构建高性能、高可用性应用的关键环节。

本文将深入探讨高级数据持久化与缓存策略，涵盖以下内容：

- **Room/SQLite 高级优化**：迁移、索引、查询计划分析、事务、WAL 模式；
- **现代键值存储**：DataStore（Preferences/Proto）与 MMKV 的原理与选型；
- **缓存核心原理**：分层缓存、淘汰策略、一致性挑战；
- **多级缓存架构设计**：Repository 模式下的缓存实现；
- **离线优先策略**：构建无缝离线体验的核心模式；
- **大数据与文件处理**：高效存储与访问技术；
- **数据同步**：保持本地与远端数据一致性的考量。

---

## 一、关系型数据持久化：SQLite 与 Room 高级技法

SQLite 是 Android 内置的轻量级关系型数据库，Room 则是 Jetpack 推荐的、在其之上提供抽象和便利的 ORM（对象关系映射）库。

### 1. SQLite 与 Room 概述

**SQLite——无处不在的基础**：理解其 ACID 特性（原子性、一致性、隔离性、持久性）、基于文件的存储方式以及 SQL 方言，对于底层优化至关重要。

**Room——简化与增强**：

- **核心优势**：编译期 SQL 校验、减少模板代码、与 LiveData/Flow/Coroutines 无缝集成、简化数据库迁移；
- **高级用法**：
  - **数据库迁移（Migration）深度实践**：
    - **必要性**：当数据库 Schema（表结构、字段等）发生变化时，需要提供迁移路径以保留用户数据；
    - **实现**：创建 Migration 子类，覆写 `migrate()` 方法，在其中执行必要的 SQL 语句（ALTER TABLE、CREATE TABLE、INSERT INTO ... SELECT 等）来转换旧 Schema 到新 Schema；
    - **复杂迁移**：对于涉及数据转换、多表操作的复杂迁移，`migrate()` 方法内可能需要执行多条 SQL，务必编写**健壮、幂等**的迁移逻辑；
    - **测试**：使用 `androidx.room:room-testing` 库提供的 MigrationTestHelper 编写单元测试，验证迁移逻辑的正确性（创建旧版本数据库 → 运行迁移 → 验证新版本数据库的 Schema 和数据）。**迁移测试是必不可少的**；
    - **自动迁移（@AutoMigration）**：Room 2.4.0+ 支持。对于简单的 Schema 变更（如添加列、重命名列/表），可以通过注解自动生成迁移，但复杂场景仍需手动 Migration；
  - **类型转换器（@TypeConverter）**：
    - **场景**：将 SQLite 不支持的自定义数据类型（如 Date、List、Bitmap、枚举，以及通过 JSON/Protobuf 序列化的复杂对象）转换为 SQLite 支持的类型（如 Long、String、BLOB）进行存储；
    - **实现**：编写包含 `@TypeConverter` 注解的静态方法，实现自定义类型与数据库支持类型之间的双向转换；
    - **性能考量**：频繁的序列化/反序列化（尤其对于复杂对象转 JSON/Proto）会有性能开销，需权衡；
  - **数据库视图（@DatabaseView）**：
    - **场景**：定义一个基于复杂查询结果的虚拟表（视图），用于封装常用的、跨多表的查询逻辑，或提供一个只读的数据投影；
    - **优点**：简化查询代码，复用查询逻辑，有时能提升查询性能；
  - **预打包数据库**：
    - **场景**：应用首次启动时需要包含一个预先填充好数据的数据库；
    - **实现**：在 assets 目录或文件系统中放置预制的 SQLite 数据库文件，在 `Room.databaseBuilder()` 中使用 `createFromAsset("database/myapp.db")` 或 `createFromFile(file)` 来加载；
    - **更新**：如果预打包数据库需要更新，需要配合版本号和迁移策略（可能需要覆盖旧文件或执行特定迁移）；
  - **多模块访问**：在模块化项目中，通常将 Database 实例和 DAOs 通过依赖注入（如 Hilt/Dagger）提供给需要访问数据库的模块。Database 定义和实例创建通常在某个核心 Data 模块中。

### 2. SQLite 性能优化

**索引策略（Indexing）——查询性能优化的关键**：

- **原理**：索引（通常是 B-Tree 结构）是一种特殊的数据结构，它根据一个或多个列的值对表中的行进行排序和存储，使得数据库可以快速定位到符合条件的行，而无需扫描整张表；
- **何时创建索引**：
  - 经常出现在 WHERE 子句中的列；
  - 用于 ORDER BY 或 GROUP BY 的列；
  - 外键列（FOREIGN KEY）通常也建议创建索引以加速 JOIN 操作；
- **索引类型**：
  - **单列索引**：`CREATE INDEX idx_name ON table_name (column_name);`
  - **复合索引（多列索引）**：`CREATE INDEX idx_composite ON table_name (col1, col2, ...);` **列的顺序非常重要**。查询条件需要匹配索引的前缀才能有效利用。例如，索引 `(col1, col2)` 可以优化 `WHERE col1=?` 和 `WHERE col1=? AND col2=?` 的查询，但通常不能优化 `WHERE col2=?` 的查询；
  - **覆盖索引（Covering Index）**：如果索引包含了查询所需的所有列（包括 SELECT 和 WHERE 子句中的列），数据库可能只需读取索引而无需访问表数据，极大提升性能；
  - **部分索引（Partial Index，SQLite 3.8+）**：只对表中满足特定条件的行创建索引（`CREATE INDEX ... WHERE condition`），可以减小索引大小，提高效率；
- **Room 中创建索引**：通过 `@Entity` 注解的 `indices` 属性（`@Entity(indices = {@Index(value = {"col1", "col2"}, unique = true)}`）或 `@Fts4`/`@Fts5` 创建全文索引；
- **权衡**：索引会加速 SELECT 查询，但会**降低** INSERT、UPDATE、DELETE 的速度，因为每次修改数据时，相关的索引也需要更新。**不要过度索引**，需要根据实际的读写模式进行分析和选择。

**查询优化（Query Optimization）**：

- **EXPLAIN QUERY PLAN**——诊断查询性能的终极工具：在查询语句前加上 `EXPLAIN QUERY PLAN`，SQLite 会返回它将如何执行该查询的计划；
  - **关注点**：
    - `SCAN TABLE table_name`：表示全表扫描，通常是性能瓶颈，需要添加索引或优化查询条件；
    - `SEARCH TABLE table_name USING INDEX index_name (...)`：表示使用了索引，通常较好；
    - `SEARCH TABLE table_name USING COVERING INDEX index_name (...)`：表示使用了覆盖索引，性能最佳；
    - `USE TEMP B-TREE FOR ORDER BY`：表示需要创建临时索引来排序，可能较慢，考虑在排序列上创建永久索引；
  - **使用方式**：可通过 Android Studio 的 Database Inspector → Run SQL，或 `adb shell sqlite3 /data/data/pkg/databases/db_name.db "EXPLAIN QUERY PLAN SELECT ..."` 来执行。根据查询计划调整索引或重写 SQL；
- **编写高效 SQL**：
  - 避免 `SELECT *`：只选择需要的列，减少数据传输和处理量；
  - 有效使用 WHERE：确保查询条件能有效利用索引；
  - 理解 JOIN：INNER JOIN、LEFT JOIN 等性能不同，确保连接键上有索引；
  - 谨慎使用 LIKE：前缀匹配（`'prefix%'`）通常能利用索引，但通配符开头（`'%suffix'`、`'%infix%'`）通常无法利用索引，会导致全表扫描，可考虑使用全文索引（FTS）；
  - **子查询与临时表**：评估其性能影响。

**事务管理（Transaction Management）**：

- **批量操作——极其重要**：将多个写操作（INSERT、UPDATE、DELETE）包裹在同一个事务中执行。Room 中使用 `@Transaction` 注解方法，或手动调用 `db.beginTransaction()`、`db.setTransactionSuccessful()`、`db.endTransaction()`；
- **原理**：事务将多次磁盘 I/O 操作（特别是日志写入）合并为一次（或少数几次），大大减少了磁盘同步的开销。对于大量写入，性能提升可能是数量级的。

**预编译语句（Prepared Statements）**：Room 默认使用。SQLite 会预编译 SQL 语句，缓存执行计划，对于重复执行的带有不同参数的 SQL 语句，可以避免重复解析和优化，提高效率。

**预写式日志（Write-Ahead Logging，WAL）模式**：

- **机制**：取代传统的回滚日志（Rollback Journal）。写操作不再直接修改数据库主文件，而是追加写入到一个单独的 `-wal` 文件中。读操作优先检查 WAL 文件是否有更新的数据，否则读取主文件。后台会周期性地将 WAL 文件中的更改**检查点（Checkpoint）**回写到主数据库文件；
- **优点**：
  - **读写并发**：读操作和写操作不再相互阻塞（读不阻塞写，写不阻塞读），极大地提高了并发性能；
  - **写入更快**：追加写 WAL 文件通常比修改主文件中的页更快；
- **缺点**：需要额外维护 WAL 和共享内存文件（`-shm`）；一个数据库可能涉及 3 个文件；Checkpoint 操作有一定开销；无法在只读文件系统上使用；
- **认知**：WAL 是现代 Android Room/SQLite 的**默认且推荐**模式。理解其工作原理有助于分析并发性能和理解文件结构。可通过 `PRAGMA journal_mode;` 查询，`PRAGMA journal_mode=WAL;` 设置。

**其他 PRAGMA 指令**：

- `synchronous`：控制磁盘同步级别（影响持久性但写入性能差异大），Room 默认值通常是安全的；
- `cache_size`：控制 SQLite 内部页缓存大小，增大可能提高读性能但增加内存占用；
- `page_size`：数据库页大小，修改需要 VACUUM；
- **建议**：除非有充分理由和测试数据支持，否则不建议随意修改这些底层 PRAGMA 设置。

**（图示：B-Tree 索引与 WAL 模式）**

```plain
B-Tree Index (Simplified):                Write-Ahead Logging (WAL):

      [ Root Node (Range) ]                 +-------------------+   read   +-------------------+
           /       \                        | Reader(s)         | <------- | Main Database File|
          /         \                       +-------------------+          | (.db)             |
         V           V                                                     +--------+----------+
 [Internal Node] [Internal Node]                                                    ^ Checkpoint
        /|\           /|\                   +-------------------+   write  +--------|----------+
       / | \         / | \                  | Writer(s)         | -------> | WAL File          |
      V  V  V       V  V  V                 +-------------------+          | (-wal)            |
 [Leaf Node]... [Leaf Node]...                                             | (Append Only Log) |
 (Contains Key & Row Pointer)                                              +-------------------+
 (Allows fast lookup via tree traversal)
                                          Shared Memory File (-shm) for coordination
```

---

## 二、键值存储：SharedPreferences 的现代替代品

对于存储少量配置、用户偏好等简单数据，键值存储是常用选择。

### 1. SharedPreferences 的「原罪」

- **主线程 IO**：`edit().commit()` 是同步写磁盘；`edit().apply()` 虽然在内存中是异步的，但最终仍会在主线程或后台线程触发同步的 fsync，可能导致卡顿或 ANR；
- **全量加载**：首次访问时会将整个 XML 文件加载到内存，如果文件过大或键值对过多，会消耗大量内存和启动时间；
- **非进程安全**：不支持跨进程安全访问；
- **无事务**：多次 `apply()` 或 `commit()` 之间没有原子性保证；
- **类型安全弱**：只能存储基本类型和 `Set<String>`；
- **结论**：**强烈建议避免在新代码中使用 SharedPreferences**，特别是对于需要频繁读写或存储稍多数据的场景。

### 2. Jetpack DataStore——官方推荐替代方案

**核心优势**：基于 Kotlin Coroutines 和 Flow，提供**异步 API**，保证主线程安全，支持**事务性更新**，并通过 Flow 提供数据变更通知。

**两种实现**：

- **Preferences DataStore**：
  - **API**：提供类似 SharedPreferences 的基于 Key 的 API（`preferencesKey<T>()`、`dataStore.data.map { it[KEY] }`、`dataStore.edit { it[KEY] = value }`）；
  - **优点**：API 熟悉，迁移成本相对较低；
  - **缺点**：仍然会将所有键值对读入内存进行操作（但操作是异步的）；不支持部分更新；需要手动处理数据迁移（从旧 SP 读取）；
  - **适用**：简单的用户偏好、设置项；
- **Proto DataStore**：
  - **API**：使用**Protocol Buffers**定义数据结构（Schema），以强类型对象的方式存储数据；
  - **定义 Schema**：在 `.proto` 文件中定义数据模型（`message Settings { string name = 1; int32 level = 2; }`）；
  - **读写**：通过生成的 Java/Kotlin 类和 DataStore API 进行读写（`dataStore.data.map { it.name }`、`dataStore.updateData { it.toBuilder().setName("...").build() }`）；
  - **优点**：
    - **类型安全**：编译期保证数据类型正确；
    - **效率高**：Protobuf 序列化/反序列化通常比 XML/JSON 更快，体积更小；
    - **支持部分更新（可能）**：Protobuf 的合并特性可能使得只更新部分字段更高效（取决于底层实现）；
    - **内置 Schema 迁移**：DataStore 提供了处理 `.proto` 文件版本变化的迁移机制（`serializer = MySettingsSerializer(migrationList)`）；
  - **缺点**：需要引入 Protobuf 依赖和学习 `.proto` 语法；样板代码稍多；
  - **适用**：结构化的配置数据、小型用户对象、需要类型安全和迁移支持的场景。

**决策**：DataStore 是 SharedPreferences 的全面升级。优先考虑 Proto DataStore 以获得类型安全和更好的长期维护性。

### 3. MMKV（来自腾讯）——高性能选项

**核心机制**：基于**内存映射（Memory Mapping，mmap）**的键值存储。它将文件直接映射到进程的虚拟地址空间，读写操作近似于直接内存访问。使用 Protobuf 进行值的序列化，通过追加写和 CRC 校验保证一定的数据一致性。

**优点**：

- **极高读写性能**：尤其是写性能远超基于文件 IO 的 SP 和 DataStore；
- **多进程支持**：内置了基于文件锁的跨进程同步机制；
- **API 简单**：提供类似 SharedPreferences 的同步 API（但也提供异步接口）；
- **支持数据加密**。

**缺点**：

- **非官方库**：需要引入第三方依赖；
- **数据一致性**：虽然有恢复机制，但在进程崩溃等极端情况下，最新写入的数据可能存在**微小概率丢失**（相比 DataStore 的事务性保证）；
- **mmap 复杂性**：内存映射本身占用虚拟地址空间，虽然不直接占用物理内存，但在 32 位进程或内存紧张时需注意。

**选型**：当**极致性能**是首要考虑因素，或者**需要便捷的多进程支持**时，MMKV 是一个非常有竞争力的选项。但需要接受其非官方地位和稍弱于 DataStore 事务性的数据一致性保证。

---

## 三、缓存核心原理与策略

缓存在应用性能优化中扮演着至关重要的角色。

### 1. 缓存的目的

减少访问慢速数据源（网络、磁盘）的次数，提高数据访问速度，降低网络流量和功耗，提升用户体验（尤其在离线或弱网时）。

### 2. 缓存层级（典型）

- **内存缓存（L1 Cache）**：
  - **介质**：RAM（堆内存）；
  - **特点**：访问速度最快（纳秒/微秒级），容量最小，生命周期最短（随进程结束而消失）；
  - **实现**：`android.util.LruCache` 是最常用的实现，基于 LRU（最近最少使用）淘汰策略。需要设置最大容量（通常根据设备可用内存动态设定）；
  - **用途**：缓存需要极快速访问且频繁使用的小对象（如解码后的 Bitmap、JSON 解析后的数据模型、计算结果）；
- **磁盘缓存（L2 Cache）**：
  - **介质**：设备内部或外部存储（文件系统）；
  - **特点**：访问速度慢于内存（毫秒级，涉及 IO），容量较大，持久化（跨进程重启保留）；
  - **实现**：
    - DiskLruCache（常见的开源实现，如 OkHttp 内部使用的）；
    - 使用 Room 数据库作为结构化数据的缓存；
    - 直接存储文件（如图片、网络响应 JSON）；
  - **用途**：缓存网络响应、图片文件、数据库查询结果、较大的数据对象；
- **网络/数据源（Source of Truth）**：
  - **介质**：远端服务器、本地数据库主数据等；
  - **特点**：访问速度最慢，容量理论上无限，是数据的最终来源。

**（图示：多级缓存层级）**

```plain
+---------------------+  Fastest Access, Smallest Size, Volatile
|    Memory Cache     | <-------------------------------- App Logic / UI
| (e.g., LruCache)    | Check First
+----------+----------+
           | Cache Miss / Stale? Check Next Level
           V
+----------+----------+  Slower Access, Larger Size, Persistent
|     Disk Cache      |
| (e.g., Room, Files) |
+----------+----------+
           | Cache Miss / Stale? Check Source
           V
+----------+----------+  Slowest Access, "Infinite" Size
|  Network / Source   |
|  of Truth (e.g. API)|
+---------------------+
           | Populate Caches on Success
           `-----------------> Disk Cache -> Memory Cache
```

### 3. 缓存淘汰策略（Eviction Policies）

当缓存满时如何移除旧数据：

- **LRU（Least Recently Used）**：移除最长时间未被访问的数据。适用于访问频率不均匀，近期访问的数据更可能被再次访问的场景。LruCache、DiskLruCache 常用；
- **LFU（Least Frequently Used）**：移除访问次数最少的数据。适用于需要保留访问频次高的数据，即使它可能不是最近访问的。实现相对复杂；
- **FIFO（First-In, First-Out）**：按存入顺序移除最早存入的数据。简单但可能淘汰掉常用数据；
- **TTL（Time-To-Live）/ Expiry**：为缓存项设置一个过期时间，到期自动失效。

### 4. 缓存一致性/失效（Cache Coherency/Invalidation）

**最困难的问题**——如何保证缓存数据与数据源同步？

- **挑战**：数据源可能在缓存不知情的情况下发生变化，导致缓存数据变为「脏」数据（Stale）；
- **常见策略**：
  - **TTL**：简单，但无法保证实时一致性；
  - **HTTP 缓存头**（Cache-Control、ETag、Last-Modified）：适用于网络缓存，依赖服务器正确配置。OkHttp Cache 可以很好地处理；
  - **轮询（Polling）**：定期检查数据源是否有更新（效率低）；
  - **主动推送（Push）**：服务器通过 Push（FCM）、SSE、WebSocket 等方式主动通知客户端数据变更，客户端收到通知后**失效（Invalidate）**或**更新（Update）**相应缓存。实时性最好，但增加系统复杂度；
  - **基于操作的失效（Action-Based Invalidation）**：当用户执行某个操作（如编辑、删除）后，程序**主动**失效相关的本地缓存。简单直接，但容易遗漏；
  - **版本号/时间戳**：数据源和缓存都维护版本号或最后更新时间戳。读取缓存时比较版本/时间戳，如果不一致则认为缓存失效；
  - **写入策略**：
    - **Write-Through**：写操作同时更新缓存和数据源。强一致性，但写性能较低；
    - **Write-Back**：写操作只更新缓存（标记为 dirty），稍后异步批量写入数据源。写性能高，但有数据丢失风险（崩溃时未写入），一致性较弱；
    - **Write-Around**：写操作直接写入数据源，不经过缓存（或使缓存失效）。读操作时再加载到缓存。

**（图示：缓存一致性问题）**

```plain
Time T1                 Time T2                     Time T3

+--------+             +--------+ (Updated)        +--------+
| Source | -- Data A --> | Source | -------------+       | Source |
+--------+             +--------+                |       +--------+
   |                                              | No Update
   | Fetched & Cached                             V
+--------+             +--------+             +--------+ STALE!
| Cache  | -- Data A --> | Cache  | -- Data A --> | Cache  |
+--------+             +--------+             +--------+
   |                      |                      |
   V                      V                      V
+--------+             +--------+             +--------+
| Client | -- Reads A -->| Client | -- Reads A -->| Client | (Reads old data)
+--------+             +--------+             +--------+
```

---

## 四、设计多级缓存架构

通常结合 Repository 模式来实现。

### 1. Repository 模式

作为数据访问的统一入口，封装数据来源（网络、数据库、缓存）的细节。ViewModel/UseCase 只与 Repository 交互。

### 2. 实现缓存逻辑

Repository 内部负责协调从不同缓存层级获取数据，并执行缓存策略。

```kotlin
// Simplified Repository Example
class UserRepository(
    private val remoteApi: UserApi,
    private val userDao: UserDao, // Room DAO (Disk Cache)
    private val memoryCache: LruCache<String, User> // Memory Cache
) {
    suspend fun getUser(userId: String): Result<User> {
        // 1. Check Memory Cache
        memoryCache.get(userId)?.let { return Result.success(it) }

        // 2. Check Disk Cache (Room)
        val userFromDb = userDao.getUserById(userId)
        if (userFromDb != null) {
             // Optional: Check if DB data is stale based on timestamp or other logic
             // if (!isStale(userFromDb)) {
                 memoryCache.put(userId, userFromDb) // Populate memory cache
                 return Result.success(userFromDb)
             // }
        }

        // 3. Fetch from Network
        return try {
            val userFromNetwork = remoteApi.fetchUser(userId)
            // 4. Update caches
            userDao.insertUser(userFromNetwork) // Update disk cache
            memoryCache.put(userId, userFromNetwork) // Update memory cache
            Result.success(userFromNetwork)
        } catch (e: Exception) {
            // Network failed, potentially return stale data or error
            if (userFromDb != null) {
                Log.w("UserRepository", "Network failed, returning stale data for $userId")
                memoryCache.put(userId, userFromDb) // Still populate memory cache with stale data
                Result.success(userFromDb) // Or return a specific "stale data" result
            } else {
                Result.failure(e)
            }
        }
    }
    // ... other methods, cache invalidation logic ...
}
```

### 3. 响应式数据流

使用 Flow 可以更优雅地实现多级缓存和数据更新。Repository 可以返回一个 Flow，该 Flow 首先发射本地数据库的数据，然后在后台触发网络请求，网络数据返回后更新数据库，数据库的变更会自动触发 Flow 发射新的数据给 UI。

```kotlin
// Simplified Reactive Repository Example
fun getUserStream(userId: String): Flow<Resource<User>> = flow {
    // 1. Emit loading state with data from DB (if exists)
    val initialData = userDao.getUserById(userId)
    emit(Resource.Loading(initialData))

    // 2. Try fetching from network
    try {
        val freshUser = remoteApi.fetchUser(userId)
        // 3. Update DB (which will trigger the flow returned by userDao.getUserFlow)
        userDao.insertUser(freshUser)
        // (Optional) Emit success explicitly if DB flow doesn't cover all cases
        // emit(Resource.Success(freshUser))
    } catch (e: Exception) {
        // 4. Emit error state, potentially keeping stale data
        emit(Resource.Error(e, initialData))
    }
    // Additionally, return a Flow directly from the DAO
    // combined with the network logic. Room's Flow will emit updates automatically.
}.combine(userDao.getUserFlow(userId)) { networkResult, dbData ->
    // Combine network status/error with latest DB data
    when (networkResult) {
        is Resource.Loading -> Resource.Loading(dbData) // Show DB data while loading
        is Resource.Success -> Resource.Success(dbData ?: networkResult.data) // Prefer fresh DB data
        is Resource.Error -> Resource.Error(networkResult.exception, dbData) // Show error with stale data
    }
}.flowOn(Dispatchers.IO) // Ensure DB & network ops are off main thread
```

> **注**：`Resource` 是一个自定义的封装类，用于表示 Loading/Success/Error 状态。

---

## 五、离线优先（Offline-First）策略

旨在提供无缝的用户体验，即使在网络连接不稳定或完全断开的情况下。

### 1. 核心原则

- **本地数据源为王**：应用的 UI **始终**从本地持久化存储（通常是 Room 数据库）读取数据并展示。本地数据库被视为**单一数据源（Single Source of Truth）**；
- **积极的本地持久化**：从网络获取的所有必要数据都应立即写入本地数据库；
- **后台同步**：与服务器的数据同步（拉取更新、推送本地更改）在后台异步进行，不阻塞 UI；
- **乐观 UI 更新（可选）**：用户执行写操作时，可以先**立即更新本地数据库和 UI**（假设操作会成功），然后将写请求放入后台队列同步到服务器。如果同步失败，需要有机制回滚 UI 或提示用户。

### 2. 实现模式

- UI 层观察（Observe）来自 Repository 的 Flow；
- Repository 返回直接来自本地数据库（Room DAO）的 Flow；
- Repository 负责触发后台同步任务（如使用 WorkManager）；
- 后台任务负责与网络 API 交互，获取数据后更新本地数据库；
- 本地数据库的更新会自动通过 Flow 传递给 UI 层，实现界面刷新；
- 用户写操作直接修改本地数据库，并触发一个后台任务将变更同步到服务器。

### 3. 挑战

- **数据同步冲突**：如果本地和服务器数据同时被修改，需要设计冲突解决策略（Last Write Wins、Server Wins、Client Wins、Merge Logic）；
- **后台同步管理**：需要健壮的后台任务调度（WorkManager 是好选择）和状态管理（同步中、成功、失败、重试）；
- **存储空间**：需要考虑本地存储占用。

---

## 六、处理大型数据与文件

存储和访问大文件（如图库图片、视频、下载的文件、大型数据库）需要特殊策略。

### 1. 流式处理（Streaming）

**核心原则**——避免将整个大文件一次性读入内存。使用 `InputStream`/`OutputStream` 或 Okio 的 `Source`/`Sink` 进行分块读写。

- **网络下载/上传**：使用流式 API 处理请求/响应体；
- **文件读写**：使用 `FileInputStream`/`FileOutputStream` 配合缓冲区。

### 2. 内存映射文件（MappedByteBuffer）

如前所述，适用于需要**随机访问**的大型**只读**文件。操作系统负责按需加载页面，避免占用大量 Java 堆内存。

### 3. 文件存储位置

- **内部存储**（`Context.getFilesDir()`、`getCacheDir()`）：应用私有，无需权限，卸载即删除。空间有限；
- **外部存储（Scoped Storage，Android 10+）**：
  - **应用专属目录**（`Context.getExternalFilesDir()`、`getExternalCacheDir()`）：应用私有，无需权限，卸载通常会删除；
  - **公共媒体集合（MediaStore）**：存储图片、音频、视频。需要 READ/WRITE_EXTERNAL_STORAGE 权限（Android 10+ 对写入有更严格限制）或使用 MediaStore API；
  - **存储访问框架（Storage Access Framework，SAF）**：让用户通过系统选择器授予应用对特定文件或目录的访问权限；
- **认知**：必须理解分区存储（Scoped Storage）带来的变化和适配要求。

### 4. 后台执行

所有文件 IO 操作必须在后台线程执行。

### 5. 部分加载/访问

- **BitmapRegionDecoder**：加载大图的指定区域，用于图片裁剪或分块显示；
- **数据库**：对于包含大 BLOB 的数据库，考虑将 BLOB 存储在单独的文件中，数据库只存文件路径，或使用流式 API 读写 BLOB。

---

## 七、数据同步与一致性考量

保持本地与远端数据同步是一大挑战。

### 1. 同步触发机制

- **轮询（Polling）**：定期检查更新（效率低，不推荐）；
- **推送通知（Push，FCM）**：服务器通知客户端有更新，客户端按需拉取（推荐）；
- **实时连接（WebSocket/SSE）**：服务器实时推送数据变更（适用于高实时性场景）；
- **后台任务调度（WorkManager）**：定期或基于事件（如网络连接时）触发后台同步。

### 2. 冲突解决（Conflict Resolution）

- **定义策略**：必须明确定义当本地修改与服务器修改冲突时的处理规则；
- **常见策略**：
  - **时间戳（Timestamp-Based）**：最后修改的数据覆盖旧数据（Last Write Wins）。简单但可能丢失用户修改；
  - **服务器优先（Server Authoritative）**：以服务器数据为准，覆盖本地修改；
  - **客户端优先（Client Authoritative）**：以本地修改为准，覆盖服务器数据（较少见）；
  - **合并（Merge）**：尝试合并双方的修改（需要复杂的逻辑和数据结构支持）；
  - **用户介入**：提示用户存在冲突，让用户选择如何解决；
- **实现**：通常在后台同步任务中检测冲突并执行解决逻辑。

---

## 八、结论：数据管理，架构之本

高级数据持久化与缓存策略是构建高性能、响应迅速、具有良好离线体验的 Android 应用的基石。不仅要熟练使用 Room、DataStore 等现代工具，更要深入理解其底层依赖（如 SQLite）的优化技巧（索引、查询计划、WAL），洞悉不同键值存储方案（DataStore vs. MMKV）的性能与一致性权衡，并能够设计出与业务场景相匹配的多级缓存架构和健壮的缓存一致性策略。

实施离线优先模式、高效处理大文件、以及妥善解决数据同步冲突，是衡量应用数据管理能力成熟度的重要指标。精通数据持久化与缓存，意味着能够从根本上优化应用性能、减少资源消耗，并最终提升用户满意度。这是一项需要结合理论深度、工具熟练度和架构智慧的综合性高级技能。
